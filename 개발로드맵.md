좋아, 이제 진짜 “만드는 순서”를 박아보자 🍶
“최소 기능 → 공통 인프라 → 커뮤니티 → 마켓 → 어드민 → ML → 꾸미기” 흐름으로 가는 게 제일 효율적이야.

0단계. 범위 쪼개기 (MVP 확정)

필수(MVP)

회원가입/로그인/로그아웃 (세션·쿠키)
사케 목록 + 상세 페이지
리뷰 작성/수정/삭제 + 사진 업로드
관리자 사케/상품 CRUD
장바구니 + 주문 요청까지만
다국어(ko/en/ja 중 최소 2개) 기본 적용

선택(시간 남으면)

ML 추천/리뷰 텍스트 분석 연동
대시보드/통계
주문 상태 관리

2단계. DB 설계 & DAO 레이어 먼저

목표: 화면 만들기 전에 데이터 흐름부터 안정화

DB 스키마 작성 & init.sql
users, sake, sake_review, sake_product, cart_item (+ orders, order_item은 나중에)
DAO 클래스 구현 (JDBC + PreparedStatement)
UserDAO, SakeDAO, ReviewDAO, ProductDAO, CartDAO
간단한 테스트 서블릿/메인 메소드로
INSERT/SELECT 정도는 미리 확인 (오타/조인 실수 미리 잡기)

3단계. 공통 기능: 회원 + 세션/쿠키

목표: 나머지 페이지의 “로그인 여부” 제어 기반 만들기

register.jsp / RegisterServlet
폼 유효성 검사(JS + 서버)
비밀번호 해시(간단히라도)
login.jsp / LoginServlet
세션에 userId, username, role 저장
“아이디 저장” 체크시 Cookie 발급
logout.jsp or LogoutServlet
session.invalidate()
공통 헤더 header.jsp에서
세션 유무에 따라 “로그인/회원가입” vs “마이페이지/로그아웃” 분기
JSTL/EL 적극 사용해서 스크립틀릿 줄이기
AuthFilter
/mypage/*, /review/*, /cart/*, /order/* 등은 로그인 체크

4단계. 커뮤니티 코어: 사케 목록 + 상세 + 리뷰

목표: Saketime 느낌 나는 “사케 정보 + 리뷰” 흐름 먼저 완성
사케 목록 페이지 (/sake/list)
SakeListServlet → sake/list.jsp
지역/스타일 필터, 페이징은 간단히라도

사케 상세 페이지 (/sake/detail?sakeId=)

상단: 사케 기본 정보 + 평균 평점 + 리뷰 수
중간: 설명/맛 프로파일
하단: 리뷰 리스트 (페이징)
리뷰 작성/수정/삭제 (/review/*)
review/form.jsp (공용 폼)
ReviewCreateServlet, ReviewUpdateServlet, ReviewDeleteServlet
로그인 사용자만 접근 가능 (filter 재사용)
리뷰 사진 파일 업로드
multipart/form-data 폼
Apache Commons FileUpload or Servlet 3.0 Part API
/uploads/review/에 저장, DB에는 파일명만 저장
JSP에서 액션 태그 사용
jsp:include로 공통 헤더/푸터
(원하면) jsp:useBean으로 리뷰 객체 바인딩

5단계. 마켓(판매) 기능: 상품 + 장바구니 + 주문 요청

목표: Sakemura 느낌의 쇼핑 플로우 구현

상품 목록 (/product/list)

ProductListServlet → product/list.jsp

필터: 스타일/지역/가격대 정도만

상품 상세 (/product/detail)

sake + sake_product join해서

커뮤니티 탭(리뷰) 재활용 → 코드 재사용 구조로 설계

장바구니 (/cart/*)

CartAddServlet, CartViewServlet, CartUpdateServlet, CartDeleteServlet

HttpSession + DB 혼합 가능하지만, 과제면 DB 기반 cart_item만 써도 충분

주문 요청 (/order/create)

배송 정보 입력 폼

orders, order_item 테이블에 INSERT

결제는 모킹(“주문이 정상적으로 접수되었습니다” 정도)

여기까지가 “마켓&커뮤니티”의 MVP 끝.
이미 평가요소(폼, 유효성 검사, DB CRUD, 세션/쿠키) 대부분 충족.

6단계. 관리자 페이지 (Admin 콘솔)

목표: CRUD를 가장 깔끔하게 보여줄 수 있는 영역 → 발표용, 평가용 핵심

role 컬럼 추가 (USER / ADMIN)

AdminAuthFilter

/admin/* 접근 시 role == ADMIN인지 체크

관리자 대시보드 (/admin/dashboard)

사케 수, 리뷰 수, 상품 수, 오늘 주문 수 등 간단한 통계

사케 관리 (/admin/sake/*)

list.jsp / form.jsp / delete

상품 관리 (/admin/product/*)

list.jsp / form.jsp

리뷰 관리 (/admin/review/*)

신고되었다고 가정하고 삭제/숨김 처리 기능

관리자는 스크립틀릿, 액션 태그, 디렉티브 태그, JSTL 다 섞어서 “JSP 문법 쇼케이스”로 쓰기 좋음.


7단계. 다국어(i18n) & UI 다듬기

목표: 평가표에 있는 “다국어 처리” 완벽 체크 + 완성도 업

messages_ko.properties, messages_en.properties, (opt) messages_ja.properties

fmt 태그 설정

taglib 디렉티브 추가

fmt:setBundle, fmt:message로 문자열 치환

언어 선택 로직

헤더에 언어 선택 드롭다운

선택 시 ?lang=ko 등 파라미터 → 세션/쿠키에 저장

Filter에서 Locale 세팅

UI/UX 간단 정리

공통 레이아웃 정리 (common/header.jsp, common/footer.jsp, common/nav.jsp)

기본 CSS 적용 (Bulma/Bootstrap 가져다 써도 OK)

이 타이밍에 스크립틀릿 조금 줄이고 JSTL/EL로 리팩토링하면 깔끔.

8단계. ML 마이크로서비스 연동 (시간 여유분)

목표: “지능형 서비스” 포인트 추가 → 보고서/발표용 임팩트

FastAPI 기본 서버 셋업 (/ml-service/app/main.py)

GET /health

POST /api/v1/recommend

POST /api/v1/analyze-taste

처음엔 더미 로직으로 시작

recommend: 랜덤 또는 단순 규칙 기반 추천

analyze-taste: 키워드 포함 여부로 태그 반환

Java 쪽에서 HTTP 호출 유틸리티 만들기

MLClient 클래스 (Apache HttpClient or HttpURLConnection)

JSP에서 추천/분석 버튼 추가

마이페이지 → “취향 기반 추천 보기”

리뷰 작성 폼 → “텍스트 분석으로 맛 태그 추천” 버튼

시간이 진짜 많이 남으면

사케/리뷰 데이터로 간단한 scikit-learn 모델(예: KNN, TF-IDF + cosine) 얹기